

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fluxfootprints.volk &mdash; fluxfootprint 0.1.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=92734c54"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            fluxfootprint
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fluxfootprints.html">fluxfootprints package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">fluxfootprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../exp.html">FluxÂ Footprints: Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modeltypes.html">Outline of Flux Measurement Footprint Estimation Approaches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/footprint.html">Quick-start notebook</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">fluxfootprint</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">fluxfootprints.volk</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for fluxfootprints.volk</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">configparser</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyproj</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.warp</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_default_transform</span><span class="p">,</span> <span class="n">reproject</span><span class="p">,</span> <span class="n">Resampling</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">affine</span><span class="w"> </span><span class="kn">import</span> <span class="n">Affine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">fluxdataqaqc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Data</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rasterio.features</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">shape</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">refet</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.improved_ffp</span><span class="w"> </span><span class="kn">import</span> <span class="n">FFPModel</span>


<div class="viewcode-block" id="load_configs">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.load_configs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_configs</span><span class="p">(</span>
    <span class="n">station</span><span class="p">,</span>
    <span class="n">config_path</span><span class="o">=</span><span class="s2">&quot;../../station_config/&quot;</span><span class="p">,</span>
    <span class="n">secrets_path</span><span class="o">=</span><span class="s2">&quot;../../secrets/config.ini&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load station metadata and secrets from configuration files.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    station : str</span>
<span class="sd">        Station identifier.</span>
<span class="sd">    config_path : str</span>
<span class="sd">        Path to station configuration file.</span>
<span class="sd">    secrets_path : str</span>
<span class="sd">        Path to secrets configuration file.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing station metadata and database URL.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">config_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">config_path</span><span class="p">)</span>

    <span class="n">config_path_loc</span> <span class="o">=</span> <span class="n">config_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">.ini&quot;</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
    <span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">config_path_loc</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">secrets_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">secrets_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">secrets_path</span><span class="p">)</span>

    <span class="n">secrets_config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
    <span class="n">secrets_config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">secrets_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="n">secrets_config</span><span class="p">[</span><span class="s2">&quot;DEFAULT&quot;</span><span class="p">][</span><span class="s2">&quot;url&quot;</span><span class="p">],</span>
        <span class="s2">&quot;latitude&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;METADATA&quot;</span><span class="p">][</span><span class="s2">&quot;station_latitude&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;longitude&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;METADATA&quot;</span><span class="p">][</span><span class="s2">&quot;station_longitude&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;elevation&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;METADATA&quot;</span><span class="p">][</span><span class="s2">&quot;station_elevation&quot;</span><span class="p">]),</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="fetch_and_preprocess_data">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.fetch_and_preprocess_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fetch_and_preprocess_data</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">startdate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve and preprocess AmeriFlux eddy covariance data for a given station.</span>

<span class="sd">    Queries a remote database for flux data starting from a specified date and</span>
<span class="sd">    performs basic preprocessing, including timestamp parsing, resampling, and</span>
<span class="sd">    handling of missing values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    url : str</span>
<span class="sd">        Base URL of the database API.</span>
<span class="sd">    station : str</span>
<span class="sd">        Station identifier string (e.g., site code or station ID).</span>
<span class="sd">    startdate : str</span>
<span class="sd">        Starting date (ISO format: &#39;YYYY-MM-DD&#39;) for data retrieval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Preprocessed DataFrame indexed by timestamp and containing hourly-averaged</span>
<span class="sd">        flux variables. Empty if retrieval fails.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Replaces `-9999` with `NaN` for missing values.</span>
<span class="sd">    - Drops rows where critical variables (&#39;h2o&#39;, &#39;wd&#39;, &#39;ustar&#39;, &#39;v_sigma&#39;) are missing.</span>
<span class="sd">    - Resamples to hourly means using `numeric_only=True`.</span>
<span class="sd">    - Assumes the API conforms to a PostgREST-style filtering syntax.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Accept-Profile&quot;</span><span class="p">:</span> <span class="s2">&quot;groundwater&quot;</span><span class="p">,</span> <span class="s2">&quot;Content-Type&quot;</span><span class="p">:</span> <span class="s2">&quot;application/json&quot;</span><span class="p">}</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stationid&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;eq.</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime_start&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;gte.</span><span class="si">{</span><span class="n">startdate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">/amfluxeddy&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;datetime_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;datetime_start&quot;</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;datetime_start&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;1h&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;h2o&quot;</span><span class="p">,</span> <span class="s2">&quot;wd&quot;</span><span class="p">,</span> <span class="s2">&quot;ustar&quot;</span><span class="p">,</span> <span class="s2">&quot;v_sigma&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to fetch data for station </span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span></div>



<div class="viewcode-block" id="multiply_directories_rast">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.multiply_directories_rast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">multiply_directories_rast</span><span class="p">(</span><span class="n">dir1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dir2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;ensemble&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply matching GeoTIFF rasters from two directories based on dates in their</span>
<span class="sd">    filenames.</span>

<span class="sd">    This function searches for GeoTIFF files in two directories (``dir1`` and</span>
<span class="sd">    ``dir2``) that share a common date string in the format ``&quot;YYYY_MM_DD&quot;``. It</span>
<span class="sd">    multiplies pairs of rasters with :func:`multiply_geotiffs` and saves the</span>
<span class="sd">    results to ``out_dir``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dir1 : pathlib.Path or str, optional</span>
<span class="sd">        Directory containing the first set of GeoTIFF files, typically with</span>
<span class="sd">        filenames ending in ``&quot;_weighted.tif&quot;``.  Defaults to</span>
<span class="sd">        ``&quot;./output/usutw/&quot;``.</span>
<span class="sd">    dir2 : pathlib.Path or str, optional</span>
<span class="sd">        Directory containing the second set of GeoTIFF files, typically with</span>
<span class="sd">        filenames starting with ``&quot;ensemble_et_&quot;``.  Defaults to</span>
<span class="sd">        ``&quot;G:/My Drive/OpenET Exports/&quot;``.</span>
<span class="sd">    out_dir : pathlib.Path or str, optional</span>
<span class="sd">        Output directory where the resulting multiplied rasters will be saved.</span>
<span class="sd">        If the directory does not exist, it is created.  Defaults to</span>
<span class="sd">        ``&quot;./output/usutw_mult/&quot;``.</span>
<span class="sd">    model : str, optional</span>
<span class="sd">        Name of the model used to identify files in ``dir2``.  Must match the</span>
<span class="sd">        fileânaming pattern (e.g., ``&quot;ensemble&quot;``, ``&quot;eemetric&quot;``, or</span>
<span class="sd">        ``&quot;ssebop&quot;``).  Default is ``&quot;ensemble&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Mapping of :class:`pandas.Timestamp` objects (derived from the matched</span>
<span class="sd">        date strings) to the result returned by :func:`multiply_geotiffs` for</span>
<span class="sd">        each raster pair.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Only files with matching ``&quot;YYYY_MM_DD&quot;`` date strings in both</span>
<span class="sd">      directories are processed.</span>
<span class="sd">    * Filenames in ``dir2`` must start with ``&quot;{model}_et_&quot;`` followed by the</span>
<span class="sd">      date.</span>
<span class="sd">    * Files without a matching pair in the other directory are skipped.</span>
<span class="sd">    * Output filenames are formatted</span>
<span class="sd">      ``&quot;weighted_{model}_openet_{YYYY_MM_DD}.tif&quot;``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pathlib import Path</span>
<span class="sd">    &gt;&gt;&gt; results = multiply_directories_rast(</span>
<span class="sd">    ...     dir1=Path(&quot;./output/usutw/&quot;),</span>
<span class="sd">    ...     dir2=Path(&quot;G:/My Drive/OpenET Exports/&quot;),</span>
<span class="sd">    ...     out_dir=Path(&quot;./output/usutw_mult/&quot;),</span>
<span class="sd">    ...     model=&quot;ensemble&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; list(results.keys())[:2]</span>
<span class="sd">    [Timestamp(&#39;2021-03-05 00:00:00&#39;), Timestamp(&#39;2021-03-06 00:00:00&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Set the paths to your two directories</span>
    <span class="k">if</span> <span class="n">dir1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dir1</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./output/usutw/&quot;</span><span class="p">)</span>  <span class="c1"># e.g., contains &#39;...20210305.tif&#39;, etc.</span>
    <span class="k">if</span> <span class="n">dir2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dir2</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;G:/My Drive/OpenET Exports/&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./output/usutw_mult/&quot;</span><span class="p">)</span>

    <span class="c1"># Check if it exists</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="c1"># Create the directory (including any necessary parent directories)</span>
        <span class="n">out_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Directory </span><span class="si">{</span><span class="n">out_dir</span><span class="si">}</span><span class="s2"> created.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Directory </span><span class="si">{</span><span class="n">out_dir</span><span class="si">}</span><span class="s2"> already exists.&quot;</span><span class="p">)</span>

    <span class="c1"># Regex pattern for an 8-digit date (adjust if your date format is different)</span>
    <span class="n">date_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d</span><span class="si">{4}</span><span class="s2">_\d</span><span class="si">{2}</span><span class="s2">_\d</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># 1) Build a dictionary of {date_string: full_path} for files in dir2</span>
    <span class="n">date_to_file_dir2</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">dir2</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">_et_*.tif&quot;</span><span class="p">):</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">date_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">filename</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">date_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">date_to_file_dir2</span><span class="p">[</span><span class="n">date_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>

    <span class="n">tsum</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># 2) Iterate over the files in dir1, extract date, and check if we have a match in dir2</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">dir1</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*_weighted.tif&quot;</span><span class="p">):</span>
        <span class="n">dt_str</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">stem</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">date_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">dt_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">date_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Check if this date exists in dir2</span>
            <span class="k">if</span> <span class="n">date_str</span> <span class="ow">in</span> <span class="n">date_to_file_dir2</span><span class="p">:</span>
                <span class="n">date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y_%m_</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">file1</span> <span class="o">=</span> <span class="n">filename</span>
                <span class="n">file2</span> <span class="o">=</span> <span class="n">date_to_file_dir2</span><span class="p">[</span><span class="n">date_str</span><span class="p">]</span>
                <span class="n">output_raster</span> <span class="o">=</span> <span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;weighted_</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">_openet_</span><span class="si">{</span><span class="n">date_str</span><span class="si">}</span><span class="s2">.tif&quot;</span>
                <span class="n">tsum</span><span class="p">[</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">multiply_geotiffs</span><span class="p">(</span><span class="n">file1</span><span class="p">,</span> <span class="n">file2</span><span class="p">,</span> <span class="n">output_raster</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tsum</span></div>



<div class="viewcode-block" id="reproject_raster_dir">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.reproject_raster_dir">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reproject_raster_dir</span><span class="p">(</span><span class="n">input_folder</span><span class="p">,</span> <span class="n">output_folder</span><span class="p">,</span> <span class="n">target_epsg</span><span class="o">=</span><span class="s2">&quot;EPSG:5070&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reproject all GeoTIFF files in a directory to a specified EPSG coordinate system.</span>

<span class="sd">    This function reads all `.tif` files in the input directory, reprojects them to the</span>
<span class="sd">    specified coordinate reference system (CRS), and saves the reprojected rasters to</span>
<span class="sd">    the output directory using the same filenames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_folder : str or pathlib.Path</span>
<span class="sd">        Path to the directory containing input GeoTIFF files.</span>
<span class="sd">    output_folder : str or pathlib.Path</span>
<span class="sd">        Path to the directory where reprojected GeoTIFF files will be saved.</span>
<span class="sd">        If the directory does not exist, it will be created.</span>
<span class="sd">    target_epsg : str, optional</span>
<span class="sd">        EPSG code of the target CRS (e.g., &quot;EPSG:5070&quot;). Default is &quot;EPSG:5070&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function performs file I/O but does not return any value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses Rasterio for reading, writing, and reprojecting GeoTIFF files.</span>
<span class="sd">    - Reprojection uses `Resampling.nearest` for band resampling.</span>
<span class="sd">    - Target transform, width, and height are calculated using `calculate_default_transform`.</span>
<span class="sd">    - The output raster preserves the number of bands and data type from the input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; reproject_raster_dir(</span>
<span class="sd">    ...     input_folder=&quot;./input_rasters&quot;,</span>
<span class="sd">    ...     output_folder=&quot;./output_rasters&quot;,</span>
<span class="sd">    ...     target_epsg=&quot;EPSG:4326&quot;</span>
<span class="sd">    ... )</span>
<span class="sd">    Reprojected ./input_rasters/file1.tif â ./output_rasters/file1.tif</span>
<span class="sd">    Reprojected ./input_rasters/file2.tif â ./output_rasters/file2.tif</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_folder</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span>

    <span class="c1"># Loop through every .tif file in the input folder</span>
    <span class="k">for</span> <span class="n">input_path</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_folder</span><span class="p">,</span> <span class="s2">&quot;*.tif&quot;</span><span class="p">)):</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">input_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># Calculate the transform, width, and height in the new CRS</span>
            <span class="n">transform</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">calculate_default_transform</span><span class="p">(</span>
                <span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">target_epsg</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="o">*</span><span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="p">)</span>

            <span class="c1"># Copy the metadata, then update with new CRS, transform, size</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;crs&quot;</span><span class="p">:</span> <span class="n">target_epsg</span><span class="p">,</span>
                    <span class="s2">&quot;transform&quot;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                    <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Build output file path</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">input_path</span><span class="p">)</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

            <span class="c1"># Reproject and save</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">reproject</span><span class="p">(</span>
                        <span class="n">source</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">band</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                        <span class="n">destination</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">band</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                        <span class="n">src_transform</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                        <span class="n">src_crs</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                        <span class="n">dst_transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                        <span class="n">dst_crs</span><span class="o">=</span><span class="n">target_epsg</span><span class="p">,</span>
                        <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reprojected </span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s2"> â </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_compute_hourly_footprint</span><span class="p">(</span><span class="n">temp_df</span><span class="p">,</span> <span class="n">station_x</span><span class="p">,</span> <span class="n">station_y</span><span class="p">,</span> <span class="n">zm</span><span class="p">,</span> <span class="n">h_s</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">origin_d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute hourly footprint climatology for a given day and location.</span>

<span class="sd">    Iterates through each hour (6:00 to 18:00 inclusive) and calculates the</span>
<span class="sd">    footprint climatology using the FFP model, based on provided meteorological</span>
<span class="sd">    inputs and station metadata. Only hours with available data are processed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    temp_df : pandas.DataFrame</span>
<span class="sd">        Filtered DataFrame containing hourly meteorological variables.</span>
<span class="sd">        Expected columns include:</span>
<span class="sd">        - &#39;mo_length&#39;: Obukhov length [m]</span>
<span class="sd">        - &#39;v_sigma&#39;: Lateral standard deviation of velocity [m/s]</span>
<span class="sd">        - &#39;ustar&#39;: Friction velocity [m/s]</span>
<span class="sd">        - &#39;ws&#39;: Wind speed [m/s]</span>
<span class="sd">        - &#39;wd&#39;: Wind direction [degrees]</span>
<span class="sd">    station_x : float</span>
<span class="sd">        UTM X-coordinate of the station [m].</span>
<span class="sd">    station_y : float</span>
<span class="sd">        UTM Y-coordinate of the station [m].</span>
<span class="sd">    zm : float</span>
<span class="sd">        Measurement height above displacement height [m].</span>
<span class="sd">    h_s : float</span>
<span class="sd">        Boundary layer height [m].</span>
<span class="sd">    z0 : float</span>
<span class="sd">        Surface roughness length [m].</span>
<span class="sd">    dx : float</span>
<span class="sd">        Grid resolution for the model domain [m].</span>
<span class="sd">    origin_d : float</span>
<span class="sd">        Domain half-width in meters (defines domain bounds as [-origin_d, origin_d]).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuple</span>
<span class="sd">        List of tuples in the format `(hour, f_2d, x_2d, y_2d)`, where:</span>
<span class="sd">        - hour : int</span>
<span class="sd">            Hour of the day (24-hour format).</span>
<span class="sd">        - f_2d : numpy.ndarray</span>
<span class="sd">            2D footprint array for the given hour.</span>
<span class="sd">        - x_2d : numpy.ndarray</span>
<span class="sd">            2D array of x-coordinates (shifted by station_x).</span>
<span class="sd">        - y_2d : numpy.ndarray</span>
<span class="sd">            2D array of y-coordinates (shifted by station_y).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Only daytime hours (6 to 18) are processed.</span>
<span class="sd">    - The footprint is masked with a cutoff filter (`mask_fp_cutoff`) after computation.</span>
<span class="sd">    - If no data is available for a given hour, it is skipped.</span>
<span class="sd">    - Errors during footprint computation are caught and logged, not raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">footprints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hour</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">19</span><span class="p">):</span>  <span class="c1"># From 7 AM to 8 PM</span>
        <span class="n">temp_line</span> <span class="o">=</span> <span class="n">temp_df</span><span class="p">[</span><span class="n">temp_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="n">hour</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">temp_line</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No data for </span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s2">:00, skipping.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ffp</span> <span class="o">=</span> <span class="n">FFPModel</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">origin_d</span><span class="p">,</span> <span class="n">origin_d</span><span class="p">,</span> <span class="o">-</span><span class="n">origin_d</span><span class="p">,</span> <span class="n">origin_d</span><span class="p">],</span>
                <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
                <span class="n">dy</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
                <span class="n">zm</span><span class="o">=</span><span class="n">zm</span><span class="p">,</span>
                <span class="n">h</span><span class="o">=</span><span class="n">h_s</span><span class="p">,</span>
                <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">z0</span><span class="o">=</span><span class="n">z0</span><span class="p">,</span>
                <span class="n">ol</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;mo_length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">sigmav</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;v_sigma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">ustar</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;ustar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">umean</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;ws&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">wind_dir</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;wd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">crop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">fig</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ffp_result</span> <span class="o">=</span> <span class="n">ffp</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="n">f_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ffp_result</span><span class="p">[</span><span class="s2">&quot;fclim_2d&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">x_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ffp_result</span><span class="p">[</span><span class="s2">&quot;x_2d&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">station_x</span>
            <span class="n">y_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ffp_result</span><span class="p">[</span><span class="s2">&quot;y_2d&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">station_y</span>
            <span class="n">f_2d</span> <span class="o">=</span> <span class="n">mask_fp_cutoff</span><span class="p">(</span><span class="n">f_2d</span><span class="p">)</span>

            <span class="n">footprints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hour</span><span class="p">,</span> <span class="n">f_2d</span><span class="p">,</span> <span class="n">x_2d</span><span class="p">,</span> <span class="n">y_2d</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error computing footprint for hour </span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">footprints</span>


<div class="viewcode-block" id="write_footprint_to_raster">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.write_footprint_to_raster">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_footprint_to_raster</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">epsg</span><span class="o">=</span><span class="mi">5070</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write hourly footprint climatologies to a multiâband GeoTIFF raster.</span>

<span class="sd">    Each band in the output GeoTIFF corresponds to one hourly footprint.  The</span>
<span class="sd">    function encodes the footprint array (``f_2d``) and annotates each band</span>
<span class="sd">    with metadata that includes the hour and the total fluxâfootprint sum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    footprints : list of tuple</span>
<span class="sd">        List of tuples in the form ``(hour, f_2d, x_2d, y_2d)`` where</span>

<span class="sd">        * **hour** (*int*) â Hour of the day (24âhour clock).</span>
<span class="sd">        * **f_2d** (*numpy.ndarray*) â 2âD footprint values.</span>
<span class="sd">        * **x_2d** (*numpy.ndarray*) â 2âD array of *x* coordinates.</span>
<span class="sd">        * **y_2d** (*numpy.ndarray*) â 2âD array of *y* coordinates.</span>
<span class="sd">    output_path : pathlib.Path or str</span>
<span class="sd">        Destination path for the output GeoTIFF.</span>
<span class="sd">    epsg : int, optional</span>
<span class="sd">        EPSG code for the coordinate reference system.  Default is ``5070``</span>
<span class="sd">        (NAD83Â /Â ConusÂ Albers).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function writes a file to disk and returns no value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Every band is labeled with the hour (e.g. ``&quot;0800&quot;``) and its total</span>
<span class="sd">      footprint sum.</span>
<span class="sd">    * Uses :func:`find_transform` on ``(y_2d, x_2d)`` to build the affine</span>
<span class="sd">      transform.</span>
<span class="sd">    * Output raster is ``float64`` with a noâdata value of ``0.0``.</span>
<span class="sd">    * If ``footprints`` is empty, no file is written and a log message is</span>
<span class="sd">      emitted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">footprints</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No footprints to write for </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">first_footprint</span> <span class="o">=</span> <span class="n">footprints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># switched x and y to get correct footprint</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">find_transform</span><span class="p">(</span><span class="n">footprints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">footprints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">n_bands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">footprints</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">output_path</span><span class="p">,</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">n_bands</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">first_footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">first_footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">epsg</span><span class="p">,</span>  <span class="c1"># Ensure this matches the projection used in `pyproj`</span>
            <span class="n">nodata</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">raster</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">hour</span><span class="p">,</span> <span class="n">f_2d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">raster</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_2d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">raster</span><span class="o">.</span><span class="n">update_tags</span><span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hour</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">00&quot;</span><span class="p">,</span> <span class="n">total_footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">f_2d</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Footprint raster saved: </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to write raster </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="weighted_rasters">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.weighted_rasters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">weighted_rasters</span><span class="p">(</span>
    <span class="n">stationid</span><span class="o">=</span><span class="s2">&quot;US-UTW&quot;</span><span class="p">,</span>
    <span class="n">start_hr</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">normed_NLDAS_stats_path</span><span class="o">=</span><span class="s2">&quot;nldas_all_normed.parquet&quot;</span><span class="p">,</span>
    <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate daily weighted footprint rasters based on hourly fetch and normalized ETo data.</span>
<span class="sd">    This function reads a Parquet file containing daily normalized ETo values for multiple</span>
<span class="sd">    stations, filters it by the specified station ID, and applies hourly weighting to existing</span>
<span class="sd">    footprint rasters. For each unweighted TIFF file in `out_dir`, the function:</span>
<span class="sd">    1. Parses the date from the filename.</span>
<span class="sd">    2. Reads hourly bands from the raster, normalizes them by their global sum, and multiplies by the normalized ETo value for that hour.</span>
<span class="sd">    3. Sums these hourly weighted rasters into a single daily footprint raster.</span>
<span class="sd">    4. Writes the result to a new file named `&lt;YYYY-MM-DD&gt;_weighted.tif` in `out_dir`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stationid : str, optional</span>
<span class="sd">        Station identifier used to look up normalized ETo values (default: &#39;US-UTW&#39;).</span>
<span class="sd">    start_hr : int, optional</span>
<span class="sd">        Starting hour for the data slice (default: 6, i.e. 7 AM).</span>
<span class="sd">    end_hr : int, optional</span>
<span class="sd">        Ending hour for the data slice (default: 18, i.e. 8 PM).</span>
<span class="sd">    normed_NLDAS_stats_path : str or pathlib.Path, optional</span>
<span class="sd">        Path to the Parquet file containing normalized ETo data (default: &#39;nldas_all_normed.parquet&#39;).</span>
<span class="sd">    out_dir : str or pathlib.Path, optional</span>
<span class="sd">        Output directory containing unweighted footprint rasters (default: current directory).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Any TIFF files in `out_dir` with filenames starting with &#39;20&#39; (e.g., &#39;2022-01-01.tif&#39;) are processed, unless they already contain the substring &#39;weighted&#39; in their filename.</span>
<span class="sd">    - The function expects the TIFF filename to be in the form &#39;YYYY-MM-DD.tif&#39; so it can parse out the date.</span>
<span class="sd">    - Only generates a weighted TIFF file if the total sum of the final footprint is within 0.15 of 1.0.</span>
<span class="sd">    - Hourly rasters with all NaN values are replaced with zeros.</span>
<span class="sd">    - Written rasters preserve the same georeferencing, resolution, and coordinate reference system as the input rasters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function does not return anything. It writes a single-band, daily-weighted footprint</span>
<span class="sd">        raster to `out_dir` for each processed date.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; weighted_rasters(</span>
<span class="sd">    ...     stationid=&#39;US-UTW&#39;,</span>
<span class="sd">    ...     start_hr=6,</span>
<span class="sd">    ...     end_hr=18,</span>
<span class="sd">    ...     normed_NLDAS_stats_path=&#39;nldas_all_normed.parquet&#39;,</span>
<span class="sd">    ...     out_dir=&#39;/path/to/tif/files&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure out_dir is a Path</span>
    <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./output/&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>

    <span class="c1"># Read the Parquet file and filter data for the specified station</span>
    <span class="n">eto_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">normed_NLDAS_stats_path</span><span class="p">)</span>
    <span class="n">eto_df</span><span class="p">[</span><span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eto_df</span><span class="p">[</span><span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
        <span class="mi">0</span>
    <span class="p">)</span>  <span class="c1"># Fill missing ETo with 0</span>
    <span class="n">nldas_df</span> <span class="o">=</span> <span class="n">eto_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stationid</span><span class="p">]</span>

    <span class="c1"># Iterate over all TIFF files in out_dir that begin with &#39;20&#39;</span>
    <span class="k">for</span> <span class="n">out_f</span> <span class="ow">in</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;20*.tif&quot;</span><span class="p">):</span>
        <span class="c1"># Skip if the file is already weighted</span>
        <span class="k">if</span> <span class="s2">&quot;weighted&quot;</span> <span class="ow">in</span> <span class="n">out_f</span><span class="o">.</span><span class="n">stem</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">out_f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Parse the date from the file name</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">out_f</span><span class="o">.</span><span class="n">stem</span><span class="p">,</span> <span class="s2">&quot;%Y_%m_</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">out_f</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> because its filename is not in &#39;YYYY-MM-DD&#39; format.&quot;</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Prepare output file name</span>
        <span class="n">final_outf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="si">:</span><span class="s2">04d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">month</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">day</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">_weighted.tif&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Skip if output already exists</span>
        <span class="k">if</span> <span class="n">final_outf</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Weighted file already exists for </span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">date</span><span class="p">()</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Open the source raster once</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">out_f</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">band_indexes</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">indexes</span>  <span class="c1"># e.g. [1, 2, 3, ...] for each hour</span>
            <span class="c1"># We&#39;ll accumulate the weighted footprint across all hours</span>
            <span class="n">normed_fetch_rasters</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">band_idx</span> <span class="ow">in</span> <span class="n">band_indexes</span><span class="p">:</span>
                <span class="c1"># The hour we are processing: band 1 corresponds to (start_hr), band 2 -&gt; (start_hr+1), etc.</span>
                <span class="n">hour</span> <span class="o">=</span> <span class="n">band_idx</span> <span class="o">+</span> <span class="n">start_hr</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">dtindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">hour</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">:00:00&quot;</span><span class="p">)</span>

                <span class="c1"># Attempt to read the normalized ETo from nldas_df</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">norm_eto</span> <span class="o">=</span> <span class="n">nldas_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dtindex</span><span class="p">,</span> <span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No NLDAS record for </span><span class="si">{</span><span class="n">dtindex</span><span class="si">}</span><span class="s2">; using 0 as fallback.&quot;</span><span class="p">)</span>
                    <span class="n">norm_eto</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">band_idx</span><span class="p">)</span>
                <span class="n">band_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

                <span class="c1"># Avoid division by zero</span>
                <span class="k">if</span> <span class="n">band_sum</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">band_sum</span><span class="p">):</span>
                    <span class="c1"># If everything is NaN or zero, use a zeros array</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Normalize by band sum</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">/</span> <span class="n">band_sum</span>

                <span class="c1"># Multiply by normalized ETo</span>
                <span class="n">weighted_arr</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">norm_eto</span>
                <span class="n">normed_fetch_rasters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weighted_arr</span><span class="p">)</span>

            <span class="c1"># Sum the weighted hourly rasters into a single daily footprint</span>
            <span class="n">final_footprint</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">normed_fetch_rasters</span><span class="p">)</span>

            <span class="c1"># Only proceed if the daily sum is close to 1.0</span>
            <span class="n">footprint_sum</span> <span class="o">=</span> <span class="n">final_footprint</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">footprint_sum</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
                <span class="c1"># Write output raster</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing weighted footprint to </span><span class="si">{</span><span class="n">final_outf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                    <span class="n">final_outf</span><span class="p">,</span>
                    <span class="s2">&quot;w&quot;</span><span class="p">,</span>
                    <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                    <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">height</span><span class="o">=</span><span class="n">final_footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">width</span><span class="o">=</span><span class="n">final_footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">transform</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                    <span class="n">crs</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                    <span class="n">nodata</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="p">)</span> <span class="k">as</span> <span class="n">out_raster</span><span class="p">:</span>
                    <span class="n">out_raster</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">final_footprint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Final footprint sum check failed for </span><span class="si">{</span><span class="n">date</span><span class="o">.</span><span class="n">date</span><span class="p">()</span><span class="si">}</span><span class="s2">: sum=</span><span class="si">{</span><span class="n">footprint_sum</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span></div>



<div class="viewcode-block" id="clip_to_utah_merge">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.clip_to_utah_merge">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clip_to_utah_merge</span><span class="p">(</span><span class="n">file_dir</span><span class="o">=</span><span class="s2">&quot;./NLDAS_data/&quot;</span><span class="p">,</span> <span class="n">years</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clip NLDAS NetCDF files to Utah boundaries and merge them by year.</span>

<span class="sd">    This function scans a directory for NetCDF files corresponding to the specified `years`,</span>
<span class="sd">    extracts data within the geographic bounds of Utah, and merges the resulting subsets</span>
<span class="sd">    along the time dimension. Outputs are saved in both NetCDF and Parquet formats.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_dir : str or pathlib.Path, optional</span>
<span class="sd">        Directory containing NLDAS NetCDF files. Defaults to &quot;./NLDAS_data/&quot;.</span>
<span class="sd">    years : list of int, optional</span>
<span class="sd">        List of years to process. If None, defaults to [2022, 2023, 2024].</span>
<span class="sd">    output_dir : str or pathlib.Path, optional</span>
<span class="sd">        Directory to store the output files. Defaults to &quot;./&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function writes files to disk but does not return anything.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Latitude bounds for Utah: 37.0 to 42.0</span>
<span class="sd">    - Longitude bounds for Utah: -114.0 to -109.0</span>
<span class="sd">    - Files are merged by year using `xarray.concat` on the `time` dimension.</span>
<span class="sd">    - Output filenames:</span>
<span class="sd">        - NetCDF:  `&lt;year&gt;_utah_merged.nc`</span>
<span class="sd">        - Parquet: `&lt;year&gt;_utah_merged.parquet`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; clip_to_utah_merge(file_dir=&quot;./NLDAS_data/&quot;, years=[2021, 2022], output_dir=&quot;./outputs/&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define Utah&#39;s latitude and longitude boundaries</span>
    <span class="n">utah_lat_min</span><span class="p">,</span> <span class="n">utah_lat_max</span> <span class="o">=</span> <span class="mf">37.0</span><span class="p">,</span> <span class="mf">42.0</span>
    <span class="n">utah_lon_min</span><span class="p">,</span> <span class="n">utah_lon_max</span> <span class="o">=</span> <span class="o">-</span><span class="mf">114.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">109.0</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_dir</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">netcdf_files</span> <span class="o">=</span> <span class="n">file_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># List of uploaded NetCDF files</span>
        <span class="n">netcdf_files</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">file_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">years</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">2022</span><span class="p">,</span> <span class="mi">2023</span><span class="p">,</span> <span class="mi">2024</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># List of uploaded NetCDF files</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="c1"># Extract Utah-specific data from each file and store datasets</span>
        <span class="n">utah_datasets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">netcdf_files</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">*.nc&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="n">ds_temp</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="n">ds_utah_temp</span> <span class="o">=</span> <span class="n">ds_temp</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">utah_lat_min</span><span class="p">,</span> <span class="n">utah_lat_max</span><span class="p">),</span>
                <span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">utah_lon_min</span><span class="p">,</span> <span class="n">utah_lon_max</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">utah_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds_utah_temp</span><span class="p">)</span>

        <span class="c1"># Merge all extracted datasets along the time dimension</span>
        <span class="n">ds_merged</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">utah_datasets</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="c1"># Save as NetCDF using a compatible format (default for xarray in this environment)</span>
        <span class="n">netcdf_output_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">_utah_merged.nc&quot;</span>
        <span class="n">ds_merged</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">netcdf_output_path</span><span class="p">)</span>

        <span class="c1"># Convert to Pandas DataFrame for Parquet format</span>
        <span class="n">df_parquet</span> <span class="o">=</span> <span class="n">ds_merged</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Save as Parquet</span>
        <span class="n">parquet_output_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">_utah_merged.parquet&quot;</span>
        <span class="n">df_parquet</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">parquet_output_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pyarrow&quot;</span><span class="p">)</span>

        <span class="c1"># Provide download links</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">netcdf_output_path</span><span class="p">,</span> <span class="n">parquet_output_path</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">calc_nldas_refet</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">nldas_out_dir</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">elevation</span><span class="p">,</span> <span class="n">zm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate reference evapotranspiration (ETr and ETo) using NLDAS data for a specific</span>
<span class="sd">    date, hour, and point location, then append or create a CSV time series of results.</span>

<span class="sd">    This function:</span>
<span class="sd">    1. Constructs a file path based on the specified year, month, day, and hour.</span>
<span class="sd">    2. Opens the corresponding NLDAS GRIB file using `xarray` and extracts the nearest grid</span>
<span class="sd">       cell to the given latitude and longitude.</span>
<span class="sd">    3. Computes hourly vapor pressure, wind speed, temperature, and solar radiation from</span>
<span class="sd">       the dataset.</span>
<span class="sd">    4. Uses the `refet` library to calculate hourly reference evapotranspiration (ETr) and</span>
<span class="sd">       reference evaporation (ETo) using the ASCE method.</span>
<span class="sd">    5. Creates or updates a CSV file (`nldas_ETr.csv`) with the calculated ETr/ETo values</span>
<span class="sd">       and relevant meteorological variables for the specified datetime.</span>
<span class="sd">    6. Returns the updated DataFrame containing all ETr/ETo records up to the current datetime.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    date : datetime.datetime</span>
<span class="sd">        The date for which to calculate reference ET.</span>
<span class="sd">    hour : int</span>
<span class="sd">        The hour (0-23) for which to calculate reference ET.</span>
<span class="sd">    nldas_out_dir : str or pathlib.Path</span>
<span class="sd">        Directory containing hour-specific NLDAS GRIB files (e.g., &quot;YYYY_MM_DD_HH.grb&quot;).</span>
<span class="sd">    latitude : float</span>
<span class="sd">        The latitude of the point of interest.</span>
<span class="sd">    longitude : float</span>
<span class="sd">        The longitude of the point of interest.</span>
<span class="sd">    elevation : float</span>
<span class="sd">        The elevation (in meters) of the point of interest.</span>
<span class="sd">    zm : float</span>
<span class="sd">        Measurement (wind) height above the ground, in meters.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A DataFrame (indexed by datetime) containing the updated ETr, ETo, and related</span>
<span class="sd">        meteorological variables (vapor pressure, specific humidity, wind speed, air</span>
<span class="sd">        pressure, temperature, solar radiation).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses the `pynio` engine for reading GRIB files with `xarray`.</span>
<span class="sd">    - Vapor pressure, wind speed, temperature, and solar radiation are computed from the</span>
<span class="sd">      NLDAS variables:</span>
<span class="sd">        * `PRES_110_SFC` (air pressure in Pa),</span>
<span class="sd">        * `SPF_H_110_HTGL` (specific humidity in kg/kg),</span>
<span class="sd">        * `U_GRD_110_HTGL` / `V_GRD_110_HTGL` (wind components in m/s),</span>
<span class="sd">        * `TMP_110_HTGL` (air temperature in K),</span>
<span class="sd">        * `DSWRF_110_SFC` (downward shortwave radiation in W/mÂ²).</span>
<span class="sd">    - It expects a valid NLDAS GRIB file matching the pattern &quot;YYYY_MM_DD_HH.grb&quot; located</span>
<span class="sd">      in `nldas_out_dir`. Otherwise, an error may occur.</span>
<span class="sd">    - The function writes results to a CSV file named `nldas_ETr.csv` within the directory</span>
<span class="sd">      `All_output/AMF/&lt;station&gt;` (the `station` variable is assumed to be defined elsewhere).</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">    &gt;&gt;&gt; calc_nldas_refet(</span>
<span class="sd">    ...     date=datetime(2023, 7, 15),</span>
<span class="sd">    ...     hour=12,</span>
<span class="sd">    ...     nldas_out_dir=Path(&quot;./NLDAS_data&quot;),</span>
<span class="sd">    ...     latitude=40.0,</span>
<span class="sd">    ...     longitude=-111.9,</span>
<span class="sd">    ...     elevation=1500,</span>
<span class="sd">    ...     zm=2.0</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YYYY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
    <span class="n">DOY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span>
    <span class="n">MM</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">month</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">day</span>
    <span class="n">HH</span> <span class="o">=</span> <span class="n">hour</span>
    <span class="c1"># already ensured to exist above loop</span>
    <span class="n">nldas_outf_path</span> <span class="o">=</span> <span class="n">nldas_out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">YYYY</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">MM</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">DD</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">HH</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">.grb&quot;</span>
    <span class="c1"># open grib and extract needed data at nearest gridcell, calc ETr/ETo anf append to time series</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">nldas_outf_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pynio&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
        <span class="n">lat_110</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span> <span class="n">lon_110</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span>
    <span class="p">)</span>
    <span class="c1"># calculate hourly ea from specific humidity</span>
    <span class="n">pair</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PRES_110_SFC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="mi">1000</span>  <span class="c1"># nldas air pres in Pa convert to kPa</span>
    <span class="n">sph</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SPF_H_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># kg/kg</span>
    <span class="n">ea</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">calcs</span><span class="o">.</span><span class="n">_actual_vapor_pressure</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">sph</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="n">pair</span><span class="p">)</span>  <span class="c1"># ea in kPa</span>
    <span class="c1"># calculate hourly wind</span>
    <span class="n">wind_u</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;U_GRD_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">wind_v</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;V_GRD_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">wind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wind_u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">wind_v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># get temp convert to C</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TMP_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="c1"># get rs</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DSWRF_110_SFC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">unit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rs&quot;</span><span class="p">:</span> <span class="s2">&quot;w/m2&quot;</span><span class="p">}</span>
    <span class="c1"># create refet object for calculating</span>

    <span class="n">refet_obj</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">Hourly</span><span class="p">(</span>
        <span class="n">tmean</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span>
        <span class="n">ea</span><span class="o">=</span><span class="n">ea</span><span class="p">,</span>
        <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">,</span>
        <span class="n">uz</span><span class="o">=</span><span class="n">wind</span><span class="p">,</span>
        <span class="n">zw</span><span class="o">=</span><span class="n">zm</span><span class="p">,</span>
        <span class="n">elev</span><span class="o">=</span><span class="n">elevation</span><span class="p">,</span>
        <span class="n">lat</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
        <span class="n">lon</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
        <span class="n">doy</span><span class="o">=</span><span class="n">DOY</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="n">HH</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;asce&quot;</span><span class="p">,</span>
        <span class="n">input_units</span><span class="o">=</span><span class="n">unit_dict</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># HH must be int</span>

    <span class="n">out_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;All_output&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;AMF&quot;</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">out_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># this one is saved under the site_ID subdir</span>
    <span class="n">nldas_ts_outf</span> <span class="o">=</span> <span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;nldas_ETr.csv&quot;</span>
    <span class="c1"># save/append time series of point data</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">YYYY</span><span class="p">,</span> <span class="n">MM</span><span class="p">,</span> <span class="n">DD</span><span class="p">,</span> <span class="n">HH</span><span class="p">)</span>
    <span class="n">ETr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ETr&quot;</span><span class="p">,</span> <span class="s2">&quot;ETo&quot;</span><span class="p">,</span> <span class="s2">&quot;ea&quot;</span><span class="p">,</span> <span class="s2">&quot;sph&quot;</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">,</span> <span class="s2">&quot;pair&quot;</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="s2">&quot;rs&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ETr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">etr</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ETo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">eto</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ea</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;sph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sph</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wind</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;pair&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;rs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;date&quot;</span>

    <span class="c1"># if first run save file with individual datetime (hour data) else open and overwrite hour</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nldas_ts_outf</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="n">ETr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">)</span>
        <span class="n">nldas_df</span> <span class="o">=</span> <span class="n">ETr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">curr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span>
        <span class="n">curr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">)</span>
        <span class="n">nldas_df</span> <span class="o">=</span> <span class="n">curr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nldas_df</span>


<div class="viewcode-block" id="calc_hourly_ffp_xr">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.calc_hourly_ffp_xr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_hourly_ffp_xr</span><span class="p">(</span>
    <span class="n">input_data_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">years</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute hourly ASCE reference evapotranspiration (ETo/ETr) for a set of</span>
<span class="sd">    **gridded** meteorological NetCDF files and append the results to each file.</span>

<span class="sd">    For every year in *years* the routine</span>

<span class="sd">    1. Opens ``&quot;&lt;year&gt;_utah_merged.nc&quot;`` from *input_data_dir* as an</span>
<span class="sd">       :class:`xarray.Dataset`.</span>
<span class="sd">    2. Derives meteorological fields required by **RefET** (air temperature in</span>
<span class="sd">      â¯Â°C, actual vapor pressureâ¯*kPa*, wind speedâ¯mâ¯sâ»Â¹, shortâwave radiation</span>
<span class="sd">      â¯Wâ¯mâ»Â²).</span>
<span class="sd">    3. Calculates hourly ETo and ETr with :pyclass:`refet.Hourly` for an</span>
<span class="sd">       elevation range of 1â¯100â¯ââ¯1â¯975â¯m (25â¯m steps).</span>
<span class="sd">    4. Stores the resulting 4âD arrays in the dataset as ``ETo`` and ``ETr``</span>
<span class="sd">       (dimensions ``elevation, time, lat, lon``).</span>
<span class="sd">    5. Writes the augmented dataset to</span>
<span class="sd">       ``&quot;&lt;year&gt;_with_eto.nc&quot;`` in *output_dir*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_data_dir : str or pathlib.Path, optional</span>
<span class="sd">        Directory that contains the yearly NetCDF files</span>
<span class="sd">        ``&quot;&lt;year&gt;_utah_merged.nc&quot;``.  Defaults to the current working</span>
<span class="sd">        directory.</span>
<span class="sd">    years : list of int, optional</span>
<span class="sd">        Years to process.  If *None* the default list</span>
<span class="sd">        ``[2021, 2022, 2023, 2024]`` is used.</span>
<span class="sd">    output_dir : str or pathlib.Path, optional</span>
<span class="sd">        Destination directory for the ``*_with_eto.nc`` files.  If *None*,</span>
<span class="sd">        the original *input_data_dir* is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function writes one NetCDF file per year and does not return a</span>
<span class="sd">        Python object.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Elevations span **1â¯100â¯m to 1â¯975â¯m a.s.l.** in 25â¯m increments,</span>
<span class="sd">      producing 36 elevation layers.</span>
<span class="sd">    * Meteorological variable names in the input files must be</span>

<span class="sd">      - ``Tair`` â¯[K] â air temperature</span>
<span class="sd">      - ``PSurf``â¯[Pa] â surface pressure</span>
<span class="sd">      - ``Qair`` â specific humidity (kgâ¯kgâ»Â¹)</span>
<span class="sd">      - ``Wind_E`` / ``Wind_N`` â eastâ and northâcomponent wind (mâ¯sâ»Â¹)</span>
<span class="sd">      - ``SWdown``â¯[Wâ¯mâ»Â²] â incident shortâwave radiation</span>

<span class="sd">    * **Units**: output ETo/ETr are in millimetres per hour (``mm/hour``).</span>
<span class="sd">    * The function prints each year to stdout as a simple progress indicator.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pathlib import Path</span>
<span class="sd">    &gt;&gt;&gt; calc_hourly_ffp_xr(</span>
<span class="sd">    ...     input_data_dir=Path(&quot;/data/met/&quot;),</span>
<span class="sd">    ...     years=[2022, 2023],</span>
<span class="sd">    ...     output_dir=Path(&quot;/data/met/eto/&quot;)</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">years</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">2022</span><span class="p">,</span> <span class="mi">2023</span><span class="p">,</span> <span class="mi">2024</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">years</span> <span class="o">=</span> <span class="n">years</span>

    <span class="k">if</span> <span class="n">input_data_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">input_data_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data_dir</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">input_data_dir</span> <span class="o">=</span> <span class="n">input_data_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_data_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">input_data_dir</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">input_data_dir</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span>
            <span class="n">input_data_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">_utah_merged.nc&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert temperature to Celsius</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Tair&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="mf">273.15</span>

        <span class="c1"># Compute actual vapor pressure (ea)</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;PSurf&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="mi">1000</span>  <span class="c1"># Convert pressure from Pa to kPa</span>
        <span class="n">sph</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Qair&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Specific humidity (kg/kg)</span>
        <span class="n">ea</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">calcs</span><span class="o">.</span><span class="n">_actual_vapor_pressure</span><span class="p">(</span>
            <span class="n">q</span><span class="o">=</span><span class="n">sph</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="n">pair</span>
        <span class="p">)</span>  <span class="c1"># Vapor pressure (kPa)</span>

        <span class="c1"># Compute wind speed from u and v components</span>
        <span class="n">wind_u</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Wind_E&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">wind_v</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Wind_N&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wind_u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">wind_v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Wind speed (m/s)</span>

        <span class="c1"># Extract shortwave radiation</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;SWdown&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Solar radiation (W/mÂ²)</span>

        <span class="c1"># Extract time variables</span>
        <span class="n">time_vals</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Convert to numpy datetime64</span>
        <span class="n">dt_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_vals</span><span class="p">)</span>  <span class="c1"># Convert to Pandas datetime index</span>
        <span class="n">DOY</span> <span class="o">=</span> <span class="n">dt_index</span><span class="o">.</span><span class="n">dayofyear</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Day of year</span>
        <span class="n">HH</span> <span class="o">=</span> <span class="n">dt_index</span><span class="o">.</span><span class="n">hour</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Hour of day</span>
        <span class="c1"># Expand DOY and HH to match (time, lat, lon) shape</span>
        <span class="n">doy_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">DOY</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">hh_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">HH</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Define measurement height (assumed)</span>
        <span class="n">zw</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># Wind measurement height in meters</span>

        <span class="c1"># Define elevation range (664m to 4125m, step 100m)</span>
        <span class="n">elevation_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1100</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>

        <span class="c1"># Create an empty array to store ETo values</span>
        <span class="n">eto_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elevation_range</span><span class="p">),)</span> <span class="o">+</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>  <span class="c1"># Shape (elevations, time, lat, lon)</span>
        <span class="n">etr_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">elevation_range</span><span class="p">),)</span> <span class="o">+</span> <span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Loop over elevations and compute ETo</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elevation_range</span><span class="p">):</span>
            <span class="n">refet_obj</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">Hourly</span><span class="p">(</span>
                <span class="n">tmean</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span>
                <span class="n">ea</span><span class="o">=</span><span class="n">ea</span><span class="p">,</span>
                <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">,</span>
                <span class="n">uz</span><span class="o">=</span><span class="n">uz</span><span class="p">,</span>
                <span class="n">zw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">elev</span><span class="o">=</span><span class="n">elev</span><span class="p">,</span>
                <span class="n">lat</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">lon</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">doy</span><span class="o">=</span><span class="n">doy_expanded</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">hh_expanded</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;asce&quot;</span><span class="p">,</span>
                <span class="n">input_units</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;rs&quot;</span><span class="p">:</span> <span class="s2">&quot;w/m2&quot;</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="n">eto_results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">eto</span><span class="p">()</span>  <span class="c1"># Store ETo results for each elevation</span>
            <span class="n">etr_results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">etr</span><span class="p">()</span>  <span class="c1"># Store ETr results for each elevation</span>

        <span class="c1"># Convert ETo results to an xarray DataArray</span>
        <span class="n">eto_da</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">eto_results</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;elevation&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;elevation&quot;</span><span class="p">:</span> <span class="n">elevation_range</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm/hour&quot;</span><span class="p">,</span>
                <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Hourly reference evapotranspiration (ASCE) at different elevations&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># Convert ETo results to an xarray DataArray</span>
        <span class="n">etr_da</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">etr_results</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;elevation&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;elevation&quot;</span><span class="p">:</span> <span class="n">elevation_range</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">],</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm/hour&quot;</span><span class="p">,</span>
                <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Hourly reference evapotranspiration (ASCE) at different elevations&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># Add ETo to the dataset</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ETo</span><span class="o">=</span><span class="n">eto_da</span><span class="p">)</span>
        <span class="c1"># Add ETo to the dataset</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ETr</span><span class="o">=</span><span class="n">etr_da</span><span class="p">)</span>

        <span class="c1"># Save the modified dataset (Optional)</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">_with_eto.nc&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="calc_hourly_ffp">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.calc_hourly_ffp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_hourly_ffp</span><span class="p">(</span>
    <span class="n">station</span><span class="p">,</span>
    <span class="n">startdate</span><span class="o">=</span><span class="s2">&quot;2022-01-01&quot;</span><span class="p">,</span>
    <span class="n">out_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">config_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">secrets_path</span><span class="o">=</span><span class="s2">&quot;../../secrets/config.ini&quot;</span><span class="p">,</span>
    <span class="n">epsg</span><span class="o">=</span><span class="mi">5070</span><span class="p">,</span>
    <span class="n">h_c</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">zm_s</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="n">dx</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
    <span class="n">h_s</span><span class="o">=</span><span class="mf">2000.0</span><span class="p">,</span>
    <span class="n">origin_d</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate and write hourly footprint climatologies for an eddyâcovariance</span>
<span class="sd">    station.</span>

<span class="sd">    The routine fetches meteorological and flux data, applies the Kljun etâ¯al.</span>
<span class="sd">    (2015) footprint model for every valid hour starting at *startdate*, and</span>
<span class="sd">    stores the results as daily multiâband GeoTIFFs (each band = one hour).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    station : str</span>
<span class="sd">        Site identifier used to locate configuration and observational data.</span>
<span class="sd">    startdate : str, optional</span>
<span class="sd">        First day to query data (``&quot;YYYYâMMâDD&quot;``).  Default is</span>
<span class="sd">        ``&quot;2022â01â01&quot;``.</span>
<span class="sd">    out_dir : str or pathlib.Path, optional</span>
<span class="sd">        Destination directory for the daily ``*_weighted.tif`` rasters.  If</span>
<span class="sd">        *None*, a folder named ``footprints`` is created next to the script.</span>
<span class="sd">    config_path : str or pathlib.Path, optional</span>
<span class="sd">        Path to a station configuration file containing metadata</span>
<span class="sd">        (latitude, longitude, elevation, tower height).</span>
<span class="sd">    secrets_path : str or pathlib.Path, optional</span>
<span class="sd">        INI file holding database credentials.  Default is</span>
<span class="sd">        ``&quot;../../secrets/config.ini&quot;``.</span>
<span class="sd">    epsg : int, optional</span>
<span class="sd">        EPSG code for the target projection; default is ``5070`` (NAD83â¯/â¯CONUS</span>
<span class="sd">        Albers).</span>
<span class="sd">    h_c : float, optional</span>
<span class="sd">        Mean canopy height *h&lt;sub&gt;c&lt;/sub&gt;*Â [m].  Default is ``0.2``.</span>
<span class="sd">    zm_s : float, optional</span>
<span class="sd">        Measurement height above ground *zâ*Â [m].  Default is ``2.0``.</span>
<span class="sd">    dx : float, optional</span>
<span class="sd">        Spatial resolution of the footprint gridÂ [m].  Default is ``3.0``.</span>
<span class="sd">    h_s : float, optional</span>
<span class="sd">        Assumed boundaryâlayer height *hâ*Â [m].  Default is ``2000.0``.</span>
<span class="sd">    origin_d : float, optional</span>
<span class="sd">        Halfâwidth of the model domain (originâ¯Â±â¯*origin_d*)Â [m].  Default is</span>
<span class="sd">        ``200.0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function writes GeoTIFFs to *out_dir* and returns no value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * A day is processed only when â¥â¯5 hourly records are valid.</span>
<span class="sd">    * Existing raster files are **not** overwritten.</span>
<span class="sd">    * Calculations use data between 06:00 and 20:00 local time.</span>
<span class="sd">    * Errors during an hourly run are logged and that hour is skipped.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; calc_hourly_ffp(&quot;US-UTW&quot;)</span>

<span class="sd">    Run in parallel for several stations:</span>

<span class="sd">    &gt;&gt;&gt; import multiprocessing as mp</span>
<span class="sd">    &gt;&gt;&gt; with mp.Pool(processes=8) as pool:</span>
<span class="sd">    ...     pool.map(calc_hourly_ffp, [&quot;US-UTW&quot;, &quot;US-XYZ&quot;, &quot;US-ABC&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">config_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;../station_config/</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">.ini&quot;</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="n">load_configs</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">config_path</span><span class="p">,</span> <span class="n">secrets_path</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">fetch_and_preprocess_data</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;url&quot;</span><span class="p">],</span> <span class="n">station</span><span class="p">,</span> <span class="n">startdate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No valid data found for station </span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">transformer</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;EPSG:</span><span class="si">{</span><span class="n">epsg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">station_y</span><span class="p">,</span> <span class="n">station_x</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.979</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">h_c</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.154</span><span class="p">)</span>
    <span class="n">zm</span> <span class="o">=</span> <span class="n">zm_s</span> <span class="o">-</span> <span class="n">d</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="n">h_c</span> <span class="o">*</span> <span class="mf">0.123</span>

    <span class="k">if</span> <span class="n">out_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./output&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">out_dir</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">out_dir</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">:</span>
        <span class="n">temp_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">between_time</span><span class="p">(</span><span class="s2">&quot;06:00&quot;</span><span class="p">,</span> <span class="s2">&quot;20:00&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_df</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Less than 5 hours of data on </span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">, skipping.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">final_outf</span> <span class="o">=</span> <span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y_%m_%d</span><span class="si">}</span><span class="s2">.tif&quot;</span>
        <span class="k">if</span> <span class="n">final_outf</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final footprint already exists: </span><span class="si">{</span><span class="n">final_outf</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">footprints</span> <span class="o">=</span> <span class="n">_compute_hourly_footprint</span><span class="p">(</span>
            <span class="n">temp_df</span><span class="p">,</span> <span class="n">station_x</span><span class="p">,</span> <span class="n">station_y</span><span class="p">,</span> <span class="n">zm</span><span class="p">,</span> <span class="n">h_s</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">origin_d</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">footprints</span><span class="p">:</span>
            <span class="n">write_footprint_to_raster</span><span class="p">(</span><span class="n">footprints</span><span class="p">,</span> <span class="n">final_outf</span><span class="p">,</span> <span class="n">epsg</span><span class="o">=</span><span class="n">epsg</span><span class="p">)</span></div>



<div class="viewcode-block" id="multiply_geotiffs">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.multiply_geotiffs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">multiply_geotiffs</span><span class="p">(</span><span class="n">input_a</span><span class="p">,</span> <span class="n">input_b</span><span class="p">,</span> <span class="n">output_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiply two GeoTIFF rasters after aligning them to the same CRS, extent, and resolution.</span>

<span class="sd">    This function opens two input rasters, reprojects the second raster to match the spatial</span>
<span class="sd">    properties of the first, multiplies them element-wise (handling NoData values gracefully),</span>
<span class="sd">    and writes the result to a new output raster file. It also prints and returns the sum of the</span>
<span class="sd">    resulting raster values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_a : str or pathlib.Path</span>
<span class="sd">        Path to the first GeoTIFF file. This raster is used as the spatial reference.</span>
<span class="sd">    input_b : str or pathlib.Path</span>
<span class="sd">        Path to the second GeoTIFF file. This raster is reprojected to match `input_a`.</span>
<span class="sd">    output_path : str or pathlib.Path</span>
<span class="sd">        Path where the output multiplied raster will be saved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The sum of the values in the output raster, excluding masked (NoData) values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The CRS, resolution, extent, and transform of `input_b` are matched to those of `input_a`</span>
<span class="sd">      using bilinear resampling.</span>
<span class="sd">    - The multiplication respects the NoData mask of `input_a`.</span>
<span class="sd">    - The resulting raster uses the data type of `input_a` and writes NoData areas as zeros.</span>
<span class="sd">    - The output raster is written as a single-band GeoTIFF.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; total = multiply_geotiffs(&quot;a.tif&quot;, &quot;b.tif&quot;, &quot;output_mult.tif&quot;)</span>
<span class="sd">    Output saved to: output_mult.tif</span>
<span class="sd">    Sum of raster values: 123456.78</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># --- Open the first raster (this will be our &quot;reference&quot; grid) ---</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">input_a</span><span class="p">)</span> <span class="k">as</span> <span class="n">src_a</span><span class="p">:</span>
        <span class="n">profile_a</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Read the full data array for A</span>
        <span class="n">data_a</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># returns a MaskedArray if there&#39;s nodata</span>

        <span class="c1"># We&#39;ll store the relevant spatial info to guide reprojecting raster B</span>
        <span class="n">ref_crs</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">crs</span>
        <span class="n">ref_transform</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">ref_width</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">width</span>
        <span class="n">ref_height</span> <span class="o">=</span> <span class="n">src_a</span><span class="o">.</span><span class="n">height</span>

        <span class="c1"># --- Open the second raster ---</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">input_b</span><span class="p">)</span> <span class="k">as</span> <span class="n">src_b</span><span class="p">:</span>
            <span class="c1"># 1) We need both rasters in the same CRS. If different, we&#39;ll reproject B.</span>
            <span class="c1"># 2) We also want B to match A&#39;s resolution and extent exactly.</span>

            <span class="c1"># Create an empty array to hold the reprojected data from B</span>
            <span class="n">data_b_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ref_height</span><span class="p">,</span> <span class="n">ref_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">src_a</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Reproject (and resample) B to match A&#39;s grid</span>
            <span class="n">reproject</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">band</span><span class="p">(</span><span class="n">src_b</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">destination</span><span class="o">=</span><span class="n">data_b_aligned</span><span class="p">,</span>
                <span class="n">src_transform</span><span class="o">=</span><span class="n">src_b</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
                <span class="n">src_crs</span><span class="o">=</span><span class="n">src_b</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                <span class="n">dst_transform</span><span class="o">=</span><span class="n">ref_transform</span><span class="p">,</span>
                <span class="n">dst_crs</span><span class="o">=</span><span class="n">ref_crs</span><span class="p">,</span>
                <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">bilinear</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># --- Perform the multiplication (masked arrays handle NoData gracefully) ---</span>
    <span class="c1"># Convert data_b_aligned to a masked array if you want to respect NoData from A</span>
    <span class="n">data_b_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_b_aligned</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">data_a</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">data_mult</span> <span class="o">=</span> <span class="n">data_a</span> <span class="o">*</span> <span class="n">data_b_masked</span>

    <span class="c1"># --- Update the profile for the output ---</span>
    <span class="c1"># We&#39;ll keep the same data type as A. If needed, you can change this (e.g., float32).</span>
    <span class="n">profile_out</span> <span class="o">=</span> <span class="n">profile_a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">profile_out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">data_mult</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># --- Write the result ---</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">profile_out</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
        <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">data_mult</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">profile_out</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]),</span> <span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># fill masked with NaN or a NoData value</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output saved to: </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="c1"># Read the first band into a NumPy array</span>
        <span class="n">band_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If you have &quot;NoData&quot; values and you&#39;d like to exclude them, you can</span>
        <span class="c1"># read the band as a masked array:</span>
        <span class="n">band_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">band_data</span><span class="p">)</span>
        <span class="c1"># Then compute the sum of all values</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">band_data</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sum of raster values:&quot;</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total_sum</span></div>



<div class="viewcode-block" id="mask_fp_cutoff">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.mask_fp_cutoff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mask_fp_cutoff</span><span class="p">(</span><span class="n">f_array</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask all values in a footprint array outside the cumulative contribution cutoff.</span>

<span class="sd">    This function applies a cumulative contribution threshold to a footprint array,</span>
<span class="sd">    keeping only the highest values that together sum to the specified `cutoff`</span>
<span class="sd">    fraction of the total. All other values are set to a small constant near zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f_array : numpy.ndarray</span>
<span class="sd">        2D array of footprint contribution values (unitless).</span>
<span class="sd">    cutoff : float, optional</span>
<span class="sd">        Fraction of the cumulative footprint to retain (default is 0.9 for 90%).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        2D array where values below the cutoff threshold are replaced with a small</span>
<span class="sd">        near-zero constant (`0.0`), and values above the threshold are retained.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The cutoff is applied based on the sorted cumulative sum of all values.</span>
<span class="sd">    - Values below the determined threshold are set to `0.0`, not NaN, to avoid</span>
<span class="sd">      issues in downstream raster calculations.</span>
<span class="sd">    - This function is useful for visualizing or focusing on the core area of a</span>
<span class="sd">      footprint (e.g., 90% contribution area).</span>
<span class="sd">    - Uses a logarithmic debug message to record the computed threshold.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; masked = mask_fp_cutoff(footprint_array, cutoff=0.8)</span>
<span class="sd">    &gt;&gt;&gt; np.sum(masked &gt; 0)</span>
<span class="sd">    150  # Number of grid cells contributing to 80% of the flux</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val_array</span> <span class="o">=</span> <span class="n">f_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">sort_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">val_array</span><span class="p">})</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;f&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sort_df</span><span class="p">[</span><span class="s2">&quot;cumsum_f&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort_df</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

    <span class="n">sort_group</span> <span class="o">=</span> <span class="n">sort_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sort_group</span><span class="p">[</span><span class="s2">&quot;cumsum_f&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="n">sum_cutoff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
    <span class="n">f_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f_array</span> <span class="o">&gt;=</span> <span class="n">sum_cutoff</span><span class="p">,</span> <span class="n">f_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">f_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">f_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.00000000e000</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mask_fp_cutoff: applied cutoff=</span><span class="si">{</span><span class="n">cutoff</span><span class="si">}</span><span class="s2">, sum_cutoff=</span><span class="si">{</span><span class="n">sum_cutoff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f_array</span></div>



<div class="viewcode-block" id="find_transform">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.find_transform">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_transform</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute an affine transform for georeferencing from 2D coordinate arrays.</span>

<span class="sd">    Given two 2D arrays of x and y coordinates representing a spatial grid, this</span>
<span class="sd">    function calculates the affine transformation matrix that maps array indices</span>
<span class="sd">    to real-world coordinates using three control points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xs : numpy.ndarray</span>
<span class="sd">        2D array of x-coordinate values (same shape as `ys`).</span>
<span class="sd">    ys : numpy.ndarray</span>
<span class="sd">        2D array of y-coordinate values (same shape as `xs`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    aff_transform : affine.Affine</span>
<span class="sd">        Affine transformation object mapping array indices to spatial coordinates.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Uses `cv2.getAffineTransform` to calculate the transform from three grid points.</span>
<span class="sd">    - The top-left, top-right, and bottom-left corners are used as control points.</span>
<span class="sd">    - Useful for writing raster data with spatial referencing in rasterio.</span>
<span class="sd">    - Assumes that `xs` and `ys` represent a regularly gridded spatial surface.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aff = find_transform(x_grid, y_grid)</span>
<span class="sd">    &gt;&gt;&gt; print(aff)</span>
<span class="sd">    Affine(2.0, 0.0, 300000.0,</span>
<span class="sd">           0.0, -2.0, 4100000.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Choose points to calculate affine transform</span>
    <span class="n">y_points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x_points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">in_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">)])</span>
    <span class="n">out_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y_points</span><span class="p">,</span> <span class="n">x_points</span><span class="p">)])</span>

    <span class="c1"># Calculate affine transform</span>
    <span class="n">aff_transform</span> <span class="o">=</span> <span class="n">Affine</span><span class="p">(</span><span class="o">*</span><span class="n">cv2</span><span class="o">.</span><span class="n">getAffineTransform</span><span class="p">(</span><span class="n">in_xy</span><span class="p">,</span> <span class="n">out_xy</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Affine transform calculated.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">aff_transform</span></div>



<div class="viewcode-block" id="download_nldas">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.download_nldas">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">download_nldas</span><span class="p">(</span>
    <span class="n">date</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span> <span class="o">|</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span>
    <span class="n">hour</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ed_user</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">ed_pass</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Download a single-hour NLDAS forcing dataset in NetCDF format.</span>

<span class="sd">    This function downloads a specific hourly NLDAS (North American Land Data Assimilation System)</span>
<span class="sd">    forcing product file from NASA GES DISC for a given date and hour using Earthdata credentials.</span>
<span class="sd">    The file is saved in a local `NLDAS_data/` directory and is skipped if it already exists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    date : datetime.date or datetime.datetime</span>
<span class="sd">        Date of the file to download.</span>
<span class="sd">    hour : int</span>
<span class="sd">        Hour of the file to download (0 to 23).</span>
<span class="sd">    ed_user : str</span>
<span class="sd">        Earthdata username for NASA GES DISC authentication.</span>
<span class="sd">    ed_pass : str</span>
<span class="sd">        Earthdata password for authentication.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function saves a NetCDF file to disk and does not return a value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Files are saved to the `NLDAS_data/` directory as: `YYYY_MM_DD_HH.nc`.</span>
<span class="sd">    - The function uses a two-step request process to handle Earthdata login redirection.</span>
<span class="sd">    - If the file already exists locally, it will not be re-downloaded.</span>
<span class="sd">    - File format: NetCDF (`.nc`) from the NLDAS_FORA0125_H.2.0 collection.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">    &gt;&gt;&gt; download_nldas(datetime(2024, 7, 15), hour=14, ed_user=&quot;myuser&quot;, ed_pass=&quot;mypassword&quot;)</span>
<span class="sd">    File NLDAS_data/2024_07_15_14.nc downloaded successfully.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NLDAS version 2, primary forcing set (a), DOY must be 3 digit zero padded, HH 2-digit between 00-23, MM and DD also 2 digit</span>
    <span class="n">YYYY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
    <span class="n">DOY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span>
    <span class="n">MM</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">month</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">day</span>
    <span class="n">HH</span> <span class="o">=</span> <span class="n">hour</span>

    <span class="n">nldas_out_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;NLDAS_data&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nldas_out_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">nldas_out_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">nldas_outf_path</span> <span class="o">=</span> <span class="n">nldas_out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">YYYY</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">MM</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">DD</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">HH</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">.nc&quot;</span>
    <span class="k">if</span> <span class="n">nldas_outf_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nldas_outf_path</span><span class="si">}</span><span class="s2"> already exists, not overwriting.&quot;</span><span class="p">)</span>
        <span class="k">pass</span>
        <span class="c1"># do not overwrite!</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># data_url = f&#39;https://hydro1.gesdisc.eosdis.nasa.gov/data/NLDAS/NLDAS_FORA0125_H.002/{YYYY}/{DOY:03}/NLDAS_FORA0125_H.A{YYYY}{MM:02}{DD:02}.{HH:02}00.002.grb&#39;</span>
        <span class="n">data_url</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;https://hydro1.gesdisc.eosdis.nasa.gov/data/NLDAS/NLDAS_FORA0125_H.2.0/</span><span class="si">{</span><span class="n">YYYY</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">DOY</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">/NLDAS_FORA0125_H.A</span><span class="si">{</span><span class="n">YYYY</span><span class="si">}{</span><span class="n">MM</span><span class="si">:</span><span class="s2">02</span><span class="si">}{</span><span class="n">DD</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">HH</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">00.020.nc&quot;</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="n">data_url</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="n">ed_user</span><span class="p">,</span> <span class="n">ed_pass</span><span class="p">))</span>

        <span class="c1"># write grib file temporarily</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">nldas_outf_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">iter_content</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>  <span class="c1"># filter out keep-alive new chunks</span>
                    <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span></div>



<div class="viewcode-block" id="read_compiled_input">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.read_compiled_input">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_compiled_input</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a CSV file that contains preâcompiled inputs for fluxâfootprint</span>
<span class="sd">    modelling, validate its contents, and return the cleaned data.</span>

<span class="sd">    The routine</span>

<span class="sd">    1. reads the file into a :class:`pandas.DataFrame`;</span>
<span class="sd">    2. parses the index as ``datetime`` and resamples to **hourly** means;</span>
<span class="sd">    3. verifies that every required variable is present;</span>
<span class="sd">    4. drops rows in which any required value is missing; and</span>
<span class="sd">    5. extracts site latitude/longitude from the first row.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str or pathlib.Path</span>
<span class="sd">        Path to the CSV file containing the preâprocessed input data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[pandas.DataFrame, float, float] or None</span>
<span class="sd">    *If* the file is valid, a tuple ``(df, latitude, longitude)``</span>

<span class="sd">    If required variables are missing or the file cannot be parsed,</span>
<span class="sd">    the function returns ``None``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Variables that *must* be present**</span>

<span class="sd">    - ``latitude``, ``longitude``</span>
<span class="sd">    - ``ET_corr``                   Â â corrected evapotranspiration</span>
<span class="sd">    - ``wind_dir``, ``u_star``, ``sigma_v``</span>
<span class="sd">    - ``zm``Â (measurement height), ``hc``Â (canopy height),</span>
<span class="sd">      ``d``Â (displacement height), ``L``Â (Obukhov length)</span>
<span class="sd">    - *Either* ``u_mean`` (mean wind speed) *or* ``z0`` (roughness length)</span>

<span class="sd">    **Optional columns that are retained if present**</span>

<span class="sd">    - ``IGBP_land_classification``</span>
<span class="sd">    - ``secondary_veg_type``</span>

<span class="sd">    The data are resampled with::</span>

<span class="sd">        df = df.resample(&quot;H&quot;).mean()</span>

<span class="sd">    and any hourly row still missing a required value is dropped.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df, lat, lon = read_compiled_input(&quot;inputs/station_data.csv&quot;)</span>
<span class="sd">    &gt;&gt;&gt; df.columns</span>
<span class="sd">    Index([&#39;latitude&#39;, &#39;longitude&#39;, &#39;ET_corr&#39;, &#39;wind_dir&#39;, &#39;u_star&#39;, &#39;sigma_v&#39;,</span>
<span class="sd">           &#39;zm&#39;, &#39;hc&#39;, &#39;d&#39;, &#39;L&#39;, &#39;u_mean&#39;],</span>
<span class="sd">          dtype=&#39;object&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">need_vars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ET_corr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;wind_dir&quot;</span><span class="p">,</span>
        <span class="s2">&quot;u_star&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sigma_v&quot;</span><span class="p">,</span>
        <span class="s2">&quot;zm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;d&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># don&#39;t parse dates first check if required inputs exist to save processing time</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">check_1</span> <span class="o">=</span> <span class="n">need_vars</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">check_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="s2">&quot;u_mean&quot;</span><span class="p">,</span> <span class="s2">&quot;z0&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">1</span>  <span class="c1"># need one or the other</span>
    <span class="c1"># if either test failed then insufficient input data for footprint, abort</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">check_2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">df</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[[</span><span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">keep_vars</span> <span class="o">=</span> <span class="n">need_vars</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;u_mean&quot;</span><span class="p">,</span> <span class="s2">&quot;z0&quot;</span><span class="p">,</span> <span class="s2">&quot;IGBP_land_classification&quot;</span><span class="p">,</span> <span class="s2">&quot;secondary_veg_type&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">drop_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">keep_vars</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;wind_dir&quot;</span><span class="p">,</span> <span class="s2">&quot;u_star&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma_v&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;zm&quot;</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="s2">&quot;ET_corr&quot;</span><span class="p">],</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span></div>



<div class="viewcode-block" id="snap_centroid">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.snap_centroid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">snap_centroid</span><span class="p">(</span><span class="n">station_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">station_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Snap station coordinates to the nearest odd multiple of 15 within a 30-meter grid.</span>

<span class="sd">    This function adjusts a UTM coordinate pair `(station_x, station_y)` such that the</span>
<span class="sd">    resulting point aligns with a 30-meter grid cell and lands on an odd multiple of 15.</span>
<span class="sd">    This helps ensure symmetry and minimizes distortion in gridded analysis (e.g., for</span>
<span class="sd">    raster-based footprint modeling).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    station_x : float</span>
<span class="sd">        Original x-coordinate (e.g., UTM Easting) of the station.</span>
<span class="sd">    station_y : float</span>
<span class="sd">        Original y-coordinate (e.g., UTM Northing) of the station.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of float</span>
<span class="sd">        The adjusted `(x, y)` coordinates snapped to the appropriate grid centroid.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The adjustment ensures that both `x` and `y` are centered on a 30-meter grid.</span>
<span class="sd">    - Coordinates are snapped to the nearest **odd multiple of 15** to avoid aligning</span>
<span class="sd">      exactly with grid cell edges.</span>
<span class="sd">    - This function is particularly useful for aligning station locations to raster grids</span>
<span class="sd">      for flux footprint or land surface model analysis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x_adj, y_adj = snap_centroid(435627.3, 4512322.7)</span>
<span class="sd">    &gt;&gt;&gt; print(x_adj, y_adj)</span>
<span class="sd">    435630.0 4512322.5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># move coord to snap centroid to 30m grid, minimal distortion</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="n">station_x</span> <span class="o">%</span> <span class="mi">15</span>
    <span class="k">if</span> <span class="n">rx</span> <span class="o">&gt;</span> <span class="mf">7.5</span><span class="p">:</span>
        <span class="n">station_x</span> <span class="o">+=</span> <span class="mi">15</span> <span class="o">-</span> <span class="n">rx</span>
        <span class="c1"># final coords should be odd factors of 15</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">station_x</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">station_x</span> <span class="o">-=</span> <span class="mi">15</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">station_x</span> <span class="o">-=</span> <span class="n">rx</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">station_x</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">station_x</span> <span class="o">+=</span> <span class="mi">15</span>

    <span class="n">ry</span> <span class="o">=</span> <span class="n">station_y</span> <span class="o">%</span> <span class="mi">15</span>
    <span class="k">if</span> <span class="n">ry</span> <span class="o">&gt;</span> <span class="mf">7.5</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ry &gt; 7.5&quot;</span><span class="p">)</span>
        <span class="n">station_y</span> <span class="o">+=</span> <span class="mi">15</span> <span class="o">-</span> <span class="n">ry</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">station_y</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">station_y</span> <span class="o">-=</span> <span class="mi">15</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ry &lt;= 7.5&quot;</span><span class="p">)</span>
        <span class="n">station_y</span> <span class="o">-=</span> <span class="n">ry</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">station_y</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">station_y</span> <span class="o">+=</span> <span class="mi">15</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;adjusted coordinates:&quot;</span><span class="p">,</span> <span class="n">station_x</span><span class="p">,</span> <span class="n">station_y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">station_x</span><span class="p">,</span> <span class="n">station_y</span></div>



<div class="viewcode-block" id="extract_nldas_xr_to_df">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.extract_nldas_xr_to_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_nldas_xr_to_df</span><span class="p">(</span>
    <span class="n">years</span><span class="p">,</span>
    <span class="n">input_path</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">config_path</span><span class="o">=</span><span class="s2">&quot;../../station_config/&quot;</span><span class="p">,</span>
    <span class="n">secrets_path</span><span class="o">=</span><span class="s2">&quot;../../secrets/config.ini&quot;</span><span class="p">,</span>
    <span class="n">output_path</span><span class="o">=</span><span class="s2">&quot;./output/&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract and compile NLDAS-derived timeseries for multiple stations into a single DataFrame.</span>

<span class="sd">    This function processes NLDAS datasets (in NetCDF format with ETo, ETr, and related variables)</span>
<span class="sd">    for specified years, extracts values for multiple stations based on their configuration `.ini`</span>
<span class="sd">    files, and writes the result to a Parquet file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    years : list of int</span>
<span class="sd">        List of years for which NLDAS NetCDF files (with ETo included) will be processed.</span>
<span class="sd">    input_path : str or pathlib.Path, optional</span>
<span class="sd">        Directory containing NetCDF input files named like `&lt;year&gt;_with_eto.nc`.</span>
<span class="sd">    config_path : str or pathlib.Path, optional</span>
<span class="sd">        Directory containing station `.ini` configuration files (e.g., `US-UTW.ini`) with keys</span>
<span class="sd">        like latitude, longitude, and elevation.</span>
<span class="sd">    secrets_path : str or pathlib.Path, optional</span>
<span class="sd">        Path to the secrets/config file used by the `load_configs` function.</span>
<span class="sd">    output_path : str or pathlib.Path, optional</span>
<span class="sd">        Directory to save the output Parquet file. Default is `./output/`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Writes a single Parquet file (`nldas_all.parquet`) containing hourly time series data</span>
<span class="sd">        indexed by station ID and datetime.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses `xarray` to open NetCDF files and `pandas` to store time series data.</span>
<span class="sd">    - It finds the nearest spatial point in the dataset for each stationâs lat/lon/elevation.</span>
<span class="sd">    - Extracted variables include: ETo, ETr, PotEvap, LWdown, SWdown, Tair, Qair, PSurf,</span>
<span class="sd">      Wind_E, and Wind_N (converted to total wind speed).</span>
<span class="sd">    - Output columns: [&#39;eto&#39;, &#39;etr&#39;, &#39;pet&#39;, &#39;lwdown&#39;, &#39;swdown&#39;, &#39;temperature&#39;,</span>
<span class="sd">      &#39;rh&#39;, &#39;pressure&#39;, &#39;wind&#39;].</span>
<span class="sd">    - Time is converted to local time by subtracting 7 hours from UTC.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; extract_nldas_xr_to_df(</span>
<span class="sd">    ...     years=[2022, 2023],</span>
<span class="sd">    ...     input_path=&quot;./NLDAS_data&quot;,</span>
<span class="sd">    ...     config_path=&quot;./station_config&quot;,</span>
<span class="sd">    ...     output_path=&quot;./output&quot;</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">input_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">config_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">config_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span>
            <span class="n">input_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s2">_with_eto.nc&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">config_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;US*.ini&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">stem</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">load_configs</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">config_path</span><span class="o">=</span><span class="n">config_path</span><span class="p">,</span> <span class="n">secrets_path</span><span class="o">=</span><span class="n">secrets_path</span>
            <span class="p">)</span>

            <span class="c1"># Define the target latitude, longitude, and elevation (adjust as needed)</span>
            <span class="n">target_lat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">])</span>
            <span class="n">target_lon</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">])</span>
            <span class="n">target_elev</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]))</span>

            <span class="c1"># Find the nearest latitude, longitude, and elevation in the dataset</span>
            <span class="n">nearest_lat</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">target_lat</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">nearest_lon</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">target_lon</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">nearest_elev</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;elevation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">elevation</span><span class="o">=</span><span class="n">target_elev</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>

            <span class="c1"># Extract ETo time series at the nearest matching location</span>
            <span class="n">eto_timeseries</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;ETo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                <span class="n">elevation</span><span class="o">=</span><span class="n">nearest_elev</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span>
            <span class="p">)</span>
            <span class="n">etr_timeseries</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;ETr&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                <span class="n">elevation</span><span class="o">=</span><span class="n">nearest_elev</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span>
            <span class="p">)</span>

            <span class="c1"># Extract PotEvap time series at the same location</span>
            <span class="n">pet_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;PotEvap&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">lwd_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;LWdown&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">swd_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;SWdown&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">temp_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Tair&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">rh_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Qair&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">pres_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;PSurf&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">wind_u_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Wind_E&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">wind_v_ts</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;Wind_N&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lat</span><span class="o">=</span><span class="n">nearest_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">nearest_lon</span><span class="p">)</span>
            <span class="n">wind_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wind_u_ts</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">wind_v_ts</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">dfs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;datetime&quot;</span><span class="p">:</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;eto&quot;</span><span class="p">:</span> <span class="n">eto_timeseries</span><span class="p">,</span>
                    <span class="s2">&quot;etr&quot;</span><span class="p">:</span> <span class="n">etr_timeseries</span><span class="p">,</span>
                    <span class="s2">&quot;pet&quot;</span><span class="p">:</span> <span class="n">pet_ts</span><span class="p">,</span>
                    <span class="s2">&quot;lwdown&quot;</span><span class="p">:</span> <span class="n">lwd_ts</span><span class="p">,</span>
                    <span class="s2">&quot;swdown&quot;</span><span class="p">:</span> <span class="n">swd_ts</span><span class="p">,</span>
                    <span class="s2">&quot;temperature&quot;</span><span class="p">:</span> <span class="n">temp_ts</span><span class="p">,</span>
                    <span class="s2">&quot;rh&quot;</span><span class="p">:</span> <span class="n">rh_ts</span><span class="p">,</span>
                    <span class="s2">&quot;pressure&quot;</span><span class="p">:</span> <span class="n">pres_ts</span><span class="p">,</span>
                    <span class="s2">&quot;wind&quot;</span><span class="p">:</span> <span class="n">wind_ts</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">dataset</span><span class="p">[</span><span class="n">year</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
    <span class="n">alldata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="n">alldata</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">alldata</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">])</span>
    <span class="n">eto_df</span> <span class="o">=</span> <span class="n">alldata</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;level_0&quot;</span><span class="p">:</span> <span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;level_1&quot;</span><span class="p">:</span> <span class="s2">&quot;stationid&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">eto_df</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eto_df</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">eto_df</span> <span class="o">=</span> <span class="n">eto_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;stationid&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>

    <span class="c1"># Save DataFrame to Parquet</span>
    <span class="n">eto_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span> <span class="o">/</span> <span class="s2">&quot;nldas_all.parquet&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="norm_minmax_dly_et">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.norm_minmax_dly_et">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">norm_minmax_dly_et</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply min-max normalization to a series of daily evapotranspiration values.</span>

<span class="sd">    This function scales input values linearly to the [0, 1] range using min-max normalization,</span>
<span class="sd">    then rounds the results to 4 decimal places.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : pandas.Series or numpy.ndarray</span>
<span class="sd">        One-dimensional array or series of daily ET values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Normalized array of values between 0 and 1, rounded to 4 decimals.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If all values in `x` are equal, the result will be `NaN` due to division by zero.</span>
<span class="sd">    - This function does not handle missing values explicitly; ensure `x` is clean beforehand.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; x = pd.Series([2.1, 2.5, 3.0, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; norm_minmax_dly_et(x)</span>
<span class="sd">    array([0.   , 0.267, 0.6  , 1.   ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Normalize using min-max scaling and then divide by the sum,</span>
    <span class="c1"># rounding to 4 decimal places.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">())),</span> <span class="mi">4</span><span class="p">)</span></div>



<div class="viewcode-block" id="norm_dly_et">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.norm_dly_et">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">norm_dly_et</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize daily evapotranspiration values by their sum.</span>

<span class="sd">    This function scales input values so that their sum equals 1, useful for generating</span>
<span class="sd">    relative daily weights. The result is rounded to 4 decimal places.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : pandas.Series or numpy.ndarray</span>
<span class="sd">        One-dimensional array or series of daily ET values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of normalized values summing to 1, rounded to 4 decimal places.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If the sum of `x` is zero, the result will contain `NaN` or `inf` values.</span>
<span class="sd">    - Ensure input is non-negative and non-empty for meaningful results.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; norm_dly_et(np.array([1.0, 2.0, 3.0]))</span>
<span class="sd">    array([0.167, 0.333, 0.5  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">4</span><span class="p">)</span></div>



<div class="viewcode-block" id="normalize_eto_df">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.normalize_eto_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_eto_df</span><span class="p">(</span><span class="n">eto_df</span><span class="p">,</span> <span class="n">eto_field</span><span class="o">=</span><span class="s2">&quot;eto&quot;</span><span class="p">):</span>
    <span class="c1"># Assuming eto_df has a datetime index or a &#39;datetime&#39; column:</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">eto_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;hour&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>

    <span class="c1"># Define the desired hour range (inclusive start, exclusive end)</span>
    <span class="n">start_hour</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">end_hour</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="c1"># Filter the DataFrame for only the hours within the specified range</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;hour&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_hour</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;hour&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_hour</span><span class="p">)</span>
    <span class="n">df_subset</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Apply the normalization for each station and each day</span>
    <span class="n">df_subset</span><span class="p">[</span><span class="s2">&quot;daily_min_max_ETo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_subset</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;stationid&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">])[</span>
        <span class="n">eto_field</span>
    <span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">norm_minmax_dly_et</span><span class="p">)</span>
    <span class="n">df_subset</span><span class="p">[</span><span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_subset</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;stationid&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">])[</span>
        <span class="s2">&quot;daily_min_max_ETo&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">norm_dly_et</span><span class="p">)</span>
    <span class="n">df_subset</span> <span class="o">=</span> <span class="n">df_subset</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;stationid&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>

    <span class="n">df_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">eto_df</span><span class="p">,</span>
        <span class="n">df_subset</span><span class="p">[[</span><span class="s2">&quot;daily_min_max_ETo&quot;</span><span class="p">,</span> <span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]],</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># df_final = df.merge(df_subset[[&#39;datetime&#39;, &#39;daily_ETo_normed&#39;]], on=&#39;datetime&#39;, how=&#39;left&#39;)</span>
    <span class="n">df_final</span><span class="p">[</span><span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_final</span><span class="p">[</span><span class="s2">&quot;daily_ETo_normed&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_final</span></div>



<div class="viewcode-block" id="calc_nldas_refet">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.calc_nldas_refet">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_nldas_refet</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">nldas_out_dir</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">elevation</span><span class="p">,</span> <span class="n">zm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize hourly ETo values by day and station using min-max and sum-based scaling.</span>

<span class="sd">    This function adds two new normalized columns to an input ETo DataFrame:</span>
<span class="sd">    - `daily_min_max_ETo`: Min-max normalized hourly ETo (0â1 range within each day).</span>
<span class="sd">    - `daily_ETo_normed`: Sum-normalized values such that daily total equals 1 (unitless weights).</span>

<span class="sd">    The normalization is applied only to hours between 6 AM and 6 PM (inclusive), and the</span>
<span class="sd">    results are merged back into the original DataFrame. Missing values are filled with 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    eto_df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing at least a datetime index or column, an ETo column, and a</span>
<span class="sd">        &#39;stationid&#39; index or column. Typically produced from NLDAS extraction routines.</span>
<span class="sd">    eto_field : str, optional</span>
<span class="sd">        Column name in `eto_df` containing the ETo values to normalize. Default is &quot;eto&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        Original DataFrame with two new columns added:</span>
<span class="sd">        - &#39;daily_min_max_ETo&#39;</span>
<span class="sd">        - &#39;daily_ETo_normed&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Time window: normalization is applied only between 6:00 and 18:00 (local time).</span>
<span class="sd">    - Grouping is performed on both &#39;stationid&#39; and calendar date.</span>
<span class="sd">    - `daily_ETo_normed` values are set to 0 outside the time window or when insufficient data exists.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; norm_df = normalize_eto_df(eto_df)</span>
<span class="sd">    &gt;&gt;&gt; norm_df[[&quot;eto&quot;, &quot;daily_ETo_normed&quot;]].head()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YYYY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">year</span>
    <span class="n">DOY</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span>
    <span class="n">MM</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">month</span>
    <span class="n">DD</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">day</span>
    <span class="n">HH</span> <span class="o">=</span> <span class="n">hour</span>
    <span class="c1"># already ensured to exist above loop</span>
    <span class="n">nldas_outf_path</span> <span class="o">=</span> <span class="n">nldas_out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">YYYY</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">MM</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">DD</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">HH</span><span class="si">:</span><span class="s2">02</span><span class="si">}</span><span class="s2">.grb&quot;</span>
    <span class="c1"># open grib and extract needed data at nearest gridcell, calc ETr/ETo anf append to time series</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">nldas_outf_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pynio&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
        <span class="n">lat_110</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span> <span class="n">lon_110</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span>
    <span class="p">)</span>
    <span class="c1"># calculate hourly ea from specific humidity</span>
    <span class="n">pair</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PRES_110_SFC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="mi">1000</span>  <span class="c1"># nldas air pres in Pa convert to kPa</span>
    <span class="n">sph</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SPF_H_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># kg/kg</span>
    <span class="n">ea</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">calcs</span><span class="o">.</span><span class="n">_actual_vapor_pressure</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">sph</span><span class="p">,</span> <span class="n">pair</span><span class="o">=</span><span class="n">pair</span><span class="p">)</span>  <span class="c1"># ea in kPa</span>
    <span class="c1"># calculate hourly wind</span>
    <span class="n">wind_u</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;U_GRD_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">wind_v</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;V_GRD_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">wind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wind_u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">wind_v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># get temp convert to C</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TMP_110_HTGL&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="c1"># get rs</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DSWRF_110_SFC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
    <span class="n">unit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rs&quot;</span><span class="p">:</span> <span class="s2">&quot;w/m2&quot;</span><span class="p">}</span>
    <span class="c1"># create refet object for calculating</span>

    <span class="n">refet_obj</span> <span class="o">=</span> <span class="n">refet</span><span class="o">.</span><span class="n">Hourly</span><span class="p">(</span>
        <span class="n">tmean</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span>
        <span class="n">ea</span><span class="o">=</span><span class="n">ea</span><span class="p">,</span>
        <span class="n">rs</span><span class="o">=</span><span class="n">rs</span><span class="p">,</span>
        <span class="n">uz</span><span class="o">=</span><span class="n">wind</span><span class="p">,</span>
        <span class="n">zw</span><span class="o">=</span><span class="n">zm</span><span class="p">,</span>
        <span class="n">elev</span><span class="o">=</span><span class="n">elevation</span><span class="p">,</span>
        <span class="n">lat</span><span class="o">=</span><span class="n">latitude</span><span class="p">,</span>
        <span class="n">lon</span><span class="o">=</span><span class="n">longitude</span><span class="p">,</span>
        <span class="n">doy</span><span class="o">=</span><span class="n">DOY</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="n">HH</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;asce&quot;</span><span class="p">,</span>
        <span class="n">input_units</span><span class="o">=</span><span class="n">unit_dict</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># HH must be int</span>

    <span class="n">out_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;All_output&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;AMF&quot;</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="n">out_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># this one is saved under the site_ID subdir</span>
    <span class="n">nldas_ts_outf</span> <span class="o">=</span> <span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;nldas_ETr.csv&quot;</span>
    <span class="c1"># save/append time series of point data</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">YYYY</span><span class="p">,</span> <span class="n">MM</span><span class="p">,</span> <span class="n">DD</span><span class="p">,</span> <span class="n">HH</span><span class="p">)</span>
    <span class="n">ETr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ETr&quot;</span><span class="p">,</span> <span class="s2">&quot;ETo&quot;</span><span class="p">,</span> <span class="s2">&quot;ea&quot;</span><span class="p">,</span> <span class="s2">&quot;sph&quot;</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">,</span> <span class="s2">&quot;pair&quot;</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="s2">&quot;rs&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ETr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">etr</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ETo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">refet_obj</span><span class="o">.</span><span class="n">eto</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;ea&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ea</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;sph&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sph</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wind</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;pair&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;rs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs</span>
    <span class="n">ETr_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;date&quot;</span>

    <span class="c1"># if first run save file with individual datetime (hour data) else open and overwrite hour</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nldas_ts_outf</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="n">ETr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">)</span>
        <span class="n">nldas_df</span> <span class="o">=</span> <span class="n">ETr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">curr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ETr_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span>
        <span class="n">curr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">nldas_ts_outf</span><span class="p">)</span>
        <span class="n">nldas_df</span> <span class="o">=</span> <span class="n">curr_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nldas_df</span></div>



<div class="viewcode-block" id="outline_valid_cells">
<a class="viewcode-back" href="../../fluxfootprints.html#fluxfootprints.volk.outline_valid_cells">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">outline_valid_cells</span><span class="p">(</span><span class="n">raster_path</span><span class="p">,</span> <span class="n">out_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract and outline the valid data extent of a raster as polygons.</span>

<span class="sd">    This function reads a raster file and identifies all non-nodata or non-NaN cells</span>
<span class="sd">    as valid. It then constructs vector polygons outlining the spatial extent of</span>
<span class="sd">    these valid regions. The result is returned as a GeoDataFrame and can optionally</span>
<span class="sd">    be saved to a GeoJSON file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raster_path : str or pathlib.Path</span>
<span class="sd">        Path to the input raster file (e.g., GeoTIFF).</span>
<span class="sd">    out_file : str or pathlib.Path, optional</span>
<span class="sd">        Path to save the resulting polygon geometry as a GeoJSON file.</span>
<span class="sd">        If None (default), the result is not saved to disk.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    geopandas.GeoDataFrame</span>
<span class="sd">        A GeoDataFrame containing one or more polygons representing the extent</span>
<span class="sd">        of valid cells. If multiple regions exist, they are dissolved into a single</span>
<span class="sd">        geometry.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If the raster has a defined `nodata` value, cells with this value are treated as invalid.</span>
<span class="sd">    - If no `nodata` is defined, the function uses NaN to identify invalid cells.</span>
<span class="sd">    - The output geometry is in the same CRS as the input raster.</span>
<span class="sd">    - Output is dissolved into one polygon using `union_all()` to form a contiguous boundary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gdf = outline_valid_cells(&quot;elevation.tif&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gdf.plot()</span>

<span class="sd">    &gt;&gt;&gt; outline_valid_cells(&quot;et_2022.tif&quot;, out_file=&quot;valid_extent.geojson&quot;)</span>
<span class="sd">    Saved valid extent polygons to &#39;valid_extent.geojson&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Open the raster</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># read the first band</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">nodata</span>

    <span class="c1"># 2. Build a &quot;valid data&quot; mask</span>
    <span class="c1">#    - If nodata is defined, use that</span>
    <span class="c1">#    - Otherwise, mask out NaNs</span>
    <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">!=</span> <span class="n">nodata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no nodata is declared, fall back to ignoring NaNs</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Convert to 8-bit integer (1 for valid, 0 for invalid)</span>
    <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">valid_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># 3. Polygonize the valid mask using rasterio.features.shapes</span>
    <span class="n">shapes_and_vals</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">shapes</span><span class="p">(</span><span class="n">valid_mask</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>

    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">shapes_and_vals</span><span class="p">:</span>
        <span class="c1"># val == 1 means it&#39;s a valid area</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">geom</span><span class="p">))</span>

    <span class="c1"># 4. Create a GeoDataFrame</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">polygons</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># 5. (Optional) dissolve all polygons into one geometry if desired</span>
    <span class="c1">#    (useful if you only want a single boundary)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">unioned_geom</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">union_all</span><span class="p">()</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">unioned_geom</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># 6. (Optional) save to file</span>
    <span class="k">if</span> <span class="n">out_file</span><span class="p">:</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved valid extent polygons to &#39;</span><span class="si">{</span><span class="n">out_file</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># load initial flux data</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="s2">&quot;US-CRT_config.ini&quot;</span><span class="p">)</span>
    <span class="c1"># adding variable names to Data instance name list for resampling</span>
    <span class="n">d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;MO_LENGTH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;MO_LENGTH&quot;</span>
    <span class="n">d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;USTAR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;USTAR&quot;</span>
    <span class="n">d</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;V_SIGMA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;V_SIGMA&quot;</span>
    <span class="c1"># renaming columns (optional and only affects windspeed and wind direction names)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">inv_map</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="c1"># get coords info from Data instance</span>
    <span class="n">latitude</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">latitude</span>
    <span class="n">longitude</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">longitude</span>
    <span class="n">station_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">)</span>
    <span class="n">station</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">site_id</span>
    <span class="c1"># get EPSG code from lat,long, convert to UTM https://epsg.io/32617</span>
    <span class="n">EPSG</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="mi">32700</span>
        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mi">45</span> <span class="o">+</span> <span class="n">latitude</span><span class="p">)</span> <span class="o">/</span> <span class="mf">90.0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="mi">183</span> <span class="o">+</span> <span class="n">longitude</span><span class="p">)</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">transformer</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;EPSG:</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">EPSG</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">station_x</span><span class="p">,</span> <span class="n">station_y</span><span class="p">)</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">station_coord</span><span class="p">)</span>
    <span class="c1"># check results, EPSG code should be 32617, lon should be near 304485 and lat 4611191</span>
    <span class="n">h_c</span> <span class="o">=</span> <span class="mf">0.2</span>  <span class="c1"># Height of canopy [m]</span>
    <span class="c1"># Estimated displacement height [m]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mf">0.979</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">h_c</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.154</span><span class="p">)</span>
    <span class="c1"># Other model parameters</span>
    <span class="n">zm_s</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># Measurement height [m] from AMF metadata</span>
    <span class="n">h_s</span> <span class="o">=</span> <span class="mf">2000.0</span>  <span class="c1"># Height of atmos. boundary layer [m] - assumed</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">3.0</span>  <span class="c1"># Model resolution [m]</span>
    <span class="n">origin_d</span> <span class="o">=</span> <span class="mf">200.0</span>  <span class="c1"># Model bounds distance from origin [m]</span>
    <span class="c1"># from 7 AM to 8 PM only, modify if needed</span>
    <span class="n">start_hr</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">end_hr</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">hours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_hr</span><span class="p">,</span> <span class="n">end_hr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Loop through each day in the dataframe</span>
    <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="p">:</span>

        <span class="c1"># Subset dataframe to only values in day of year</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Date: </span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">temp_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span> <span class="o">==</span> <span class="n">date</span><span class="p">]</span>

        <span class="n">new_dat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hours</span><span class="p">):</span>

            <span class="n">band</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hour: </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">temp_line</span> <span class="o">=</span> <span class="n">temp_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temp_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># Calculate footprint</span>
                <span class="n">ffpout</span> <span class="o">=</span> <span class="n">FFPModel</span><span class="p">(</span>
                    <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">origin_d</span><span class="p">,</span> <span class="n">origin_d</span><span class="p">,</span> <span class="o">-</span><span class="n">origin_d</span><span class="p">,</span> <span class="n">origin_d</span><span class="p">],</span>
                    <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
                    <span class="n">dy</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
                    <span class="n">zm</span><span class="o">=</span><span class="n">zm_s</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span>
                    <span class="n">h</span><span class="o">=</span><span class="n">h_s</span><span class="p">,</span>
                    <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">z0</span><span class="o">=</span><span class="n">h_c</span> <span class="o">*</span> <span class="mf">0.123</span><span class="p">,</span>
                    <span class="n">ol</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;MO_LENGTH&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">sigmav</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;V_SIGMA&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">ustar</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;USTAR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>  <span class="c1"># umean=temp_line[&#39;ws&#39;].values,</span>
                    <span class="n">wind_dir</span><span class="o">=</span><span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;wd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">crop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">fig</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1">####verbosoity=2 prints out errors; if z0 triggers errors, use umean</span>
                <span class="c1">#    print(zm_s-d)</span>
                <span class="n">temp_ffp</span> <span class="o">=</span> <span class="n">ffpout</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
                <span class="n">f_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp_ffp</span><span class="p">[</span><span class="s2">&quot;fclim_2d&quot;</span><span class="p">])</span>
                <span class="n">x_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp_ffp</span><span class="p">[</span><span class="s2">&quot;x_2d&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">station_x</span>
                <span class="n">y_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp_ffp</span><span class="p">[</span><span class="s2">&quot;y_2d&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">station_y</span>
                <span class="n">f_2d</span> <span class="o">=</span> <span class="n">f_2d</span> <span class="o">*</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span>

                <span class="c1"># Calculate affine transform for given x_2d and y_2d</span>
                <span class="n">affine_transform</span> <span class="o">=</span> <span class="n">find_transform</span><span class="p">(</span><span class="n">x_2d</span><span class="p">,</span> <span class="n">y_2d</span><span class="p">)</span>

                <span class="c1"># Create data file if not already created</span>
                <span class="k">if</span> <span class="n">new_dat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out_f</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">station</span><span class="si">}</span><span class="s2">.tif&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">new_dat</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                        <span class="n">out_f</span><span class="p">,</span>
                        <span class="s2">&quot;w&quot;</span><span class="p">,</span>
                        <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                        <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">hours</span><span class="p">),</span>
                        <span class="n">height</span><span class="o">=</span><span class="n">f_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">width</span><span class="o">=</span><span class="n">f_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">transform</span><span class="o">=</span><span class="n">affine_transform</span><span class="p">,</span>
                        <span class="n">crs</span><span class="o">=</span><span class="n">pyproj</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">EPSG</span><span class="p">)),</span>
                        <span class="n">nodata</span><span class="o">=</span><span class="mf">0.00000000e000</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hour </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> footprint failed, band </span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s2"> not written.&quot;</span><span class="p">)</span>

                <span class="n">temp_ffp</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">continue</span>

            <span class="c1"># Mask out points that are below a % threshold (defaults to 90%)</span>
            <span class="n">f_2d</span> <span class="o">=</span> <span class="n">mask_fp_cutoff</span><span class="p">(</span><span class="n">f_2d</span><span class="p">)</span>

            <span class="c1"># Write the new band</span>
            <span class="n">new_dat</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_2d</span><span class="p">,</span> <span class="n">indx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Update tags with metadata</span>
            <span class="n">tag_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;hour&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">04</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s2">&quot;wind_dir&quot;</span><span class="p">:</span> <span class="n">temp_line</span><span class="p">[</span><span class="s2">&quot;wd&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="s2">&quot;total_footprint&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">f_2d</span><span class="p">),</span>
            <span class="p">}</span>

            <span class="n">new_dat</span><span class="o">.</span><span class="n">update_tags</span><span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">tag_dict</span><span class="p">)</span>

        <span class="c1"># Close dataset if it exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_dat</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># for esample just create a single day and exit</span>
        <span class="k">break</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Paul Inkenbrandt, Natascha Kljun, John Volk.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>